# DataAnalytics-Assessment

## Question 1
In this task, the objective was to find clients who actively participate in both investment and savings activities. To do this, I retrieved each customer's complete name by querying the `plans_plan` table, which has comprehensive details of each user's investment and savings plans, and joining it with the `users_customuser` table.  The conditions is_regular_savings = 1 and is_fixed_investment = 1 were used to identify a savings plan and an investment strategy, respectively.

I only considered users whose first_name and last_name were not null to guarantee the veracity of our findings.  Plans with negative quantity values were also thrown out because they were either test data or abnormalities in the system.  I determined how many investment and savings plans each user had and how much they had deposited overall using aggregate functions.  Only users with at least one savings and one investment plan were kept in the query, which aggregated data by user and used a HAVING clause.  In order to identify the most financially engaged users, the results were finally arranged in descending order by the total amount deposited.

One difficulty was figuring out the amount field's relevance, which was overcome by understanding it as the actual deposited value as opposed to a target or estimate.  Incomplete client records were another problem, which was fixed by removing users with missing names.  A clear, ranked list of hybrid savers is the end product, which can be used for rewards schemes or targeted advertising.

## Question 2
This question's goal was to divide clients into three frequency-based groups —High, Medium, and Low—according to how frequently they make purchases each month.  I did this by running a query on the savings_savingsaccount table, which keeps track of every customer savings transaction.  I began by aggregating each user's transactions using a combination of their owner_id and the month of the transaction_date in order to get their monthly transaction volumes.  For every month that the user was active, this generated a transaction count for them.

I then calculated each `customer's average monthly transaction` count by averaging their monthly transaction counts.  I created a segmentation logic using a CASE statement based on this average, classifying clients with 10 or more transactions per month as `"High Frequency,"` those with 3 to 9 as `"Medium Frequency,"` and users with fewer than 3 as `"Low Frequency."`

After calculating the average transaction frequency for each frequency segment, I used these figures to determine the number of users that fit into each one.  After that, the segment hierarchy was used to organize the results in order to guarantee even reporting.  This endeavor was complicated by the need to accurately calculate monthly transaction volumes while taking users with erratic activity into account.  To solve this, transaction months were separated out, and only active times were averaged.  By providing insightful information about client engagement patterns, the finished product can help customize retention or upsell tactics according to usage trends.

## Question 3
By identifying those financial plans that have not had any successful transactions in the last year, this question sought to detect inactive financial plans.  To find inactivity across both savings and investment plans, the reasoning entailed examining the `plans_plan` and `savings_savingsaccount` tables.  First, I used the plan_id to left join the `savings_savingsaccount` transactions to the `plans_plan` database, filtering only the successful transactions with a positive amount to eliminate test or failed records.

I eliminated plans that had been archived or removed in order to guarantee the results' applicability.  For each plan, I then used MAX(s.transaction_date) to get the date of the most recent completed transaction.  The inactivity_days was then calculated by subtracting the current date from the date of the last transaction.

## Question 4
I used transaction records and user account information to estimate the Customer Lifetime Value, making sure to focus on successful transactions to guarantee accuracy.  Based on their signup date, I determined each customer's account tenure in months before tallying all of their transactions.  By measuring the average monthly number of transactions, annualizing it, and multiplying by the average profit per transaction—0.1% of the transaction amount—the CLV was calculated.  To ensure accurate profit computations, the unit conversion from kobo to a standard currency has to be handled.  I used SQL's NULLIF function to overcome a major challenge: avoiding division by zero in situations when tenure might be zero.  The most valued customers were highlighted by sorting the final findings by descending CLV.